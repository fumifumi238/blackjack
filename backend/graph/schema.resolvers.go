package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"
	"fmt"
	"math/rand"

	"card_game/backend/graph/model"
)

// StartGame is the resolver for the startGame field.
func (r *mutationResolver) StartGame(ctx context.Context) (*model.Game, error) {
	gameID := fmt.Sprintf("%d", rand.Int63())
	deck := createDeck()
	playerHand := []*model.Card{deck[0], deck[1]}
	dealerHand := []*model.Card{deck[2], deck[3]}
	deck = deck[4:]
	status := "playing"
	playerScore := calculateScore(playerHand)
	dealerScore := calculateScore(dealerHand)
	game := model.Game{
		ID:          &gameID,
		PlayerHand:  playerHand,
		DealerHand:  dealerHand,
		Status:      status,
		PlayerScore: &playerScore,
		DealerScore: &dealerScore,
		Deck:        deck,
	}
	err := saveGame(game)
	if err != nil {
		return nil, err
	}
	broadcastGame(game)
	return &game, nil
}

// Hit is the resolver for the hit field.
func (r *mutationResolver) Hit(ctx context.Context, id string) (*model.Game, error) {
	game, err := loadGame(id)
	if err != nil {
		return nil, err
	}
	if game.Status != "playing" {
		return &game, nil
	}
	if len(game.Deck) == 0 {
		return nil, fmt.Errorf("no cards left")
	}
	game.PlayerHand = append(game.PlayerHand, game.Deck[0])
	game.Deck = game.Deck[1:]
	score := calculateScore(game.PlayerHand)
	if score > 21 {
		status := "bust"
		game.Status = status
	}
	playerScore := score
	game.PlayerScore = &playerScore
	err = saveGame(game)
	if err != nil {
		return nil, err
	}
	broadcastGame(game)
	return &game, nil
}

// Stand is the resolver for the stand field.
func (r *mutationResolver) Stand(ctx context.Context, id string) (*model.Game, error) {
	game, err := loadGame(id)
	if err != nil {
		return nil, err
	}
	if game.Status != "playing" {
		return &game, nil
	}
	// Dealer plays
	for calculateScore(game.DealerHand) < 17 && len(game.Deck) > 0 {
		game.DealerHand = append(game.DealerHand, game.Deck[0])
		game.Deck = game.Deck[1:]
	}
	playerScore := calculateScore(game.PlayerHand)
	dealerScore := calculateScore(game.DealerHand)
	var status string
	switch {
	case dealerScore > 21:
		status = "player_win"
	case playerScore > dealerScore:
		status = "player_win"
	case playerScore < dealerScore:
		status = "dealer_win"
	default:
		status = "draw"
	}
	game.Status = status
	game.PlayerScore = &playerScore
	game.DealerScore = &dealerScore
	err = saveGame(game)
	if err != nil {
		return nil, err
	}
	broadcastGame(game)
	return &game, nil
}

// GameState is the resolver for the gameState field.
func (r *queryResolver) GameState(ctx context.Context, id string) (*model.Game, error) {
	game, err := loadGame(id)
	if err != nil {
		return nil, err
	}
	playerScore := calculateScore(game.PlayerHand)
	dealerScore := calculateScore(game.DealerHand)
	game.PlayerScore = &playerScore
	game.DealerScore = &dealerScore
	return &game, nil
}

// GameUpdated is the resolver for the gameUpdated field.
func (r *subscriptionResolver) GameUpdated(ctx context.Context) (<-chan *model.Game, error) {
	gameChan := make(chan *model.Game, 1)
	go func() {
		defer close(gameChan)
		for {
			select {
			case game := <-broadcast:
				gameChan <- &game
			case <-ctx.Done():
				return
			}
		}
	}()
	return gameChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type (
	mutationResolver     struct{ *Resolver }
	queryResolver        struct{ *Resolver }
	subscriptionResolver struct{ *Resolver }
)
